# 63.不同路径II

力扣链接：https://leetcode.cn/problems/unique-paths-ii/

---

有尝试自己写，但是递推公式不对，初始化的时候也没有考虑完全，再多做几题看看会不会有点手感

---

**思路：**

1. **dp[i][j]含义：** 到达 (i,j) 位置的走法数量，**i,j** 含义：(i,j) 位置   
2. **递推公式** dp[i][j] = dp[i-1][j] + dp[i][j-1] 走到(i,j)位置，无非就是从 上移一格 或者 左移一格 的位置移动过来（题目说只能向下/右走），故而到(i,j)就是二者相加，
同时在执行递推公式前，要先判断该格是否有障碍
3. **初始化** dp[i][0] = 1, dp[0][j] = 1; 只能向下/右走，故而在起始行/列的格子，从起始点开始，都只有一种走法，但是，要加一个先决条件：该格没有障碍
4. **遍历顺序** 从上往下。从左往右遍历

---

## 代码

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        // 获取长和宽，定义dp：到（i，j）的走法数量
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        vector<vector<int>> dp(m, vector<int>(n,0));

        // 考虑起点终点的情况
        if(obstacleGrid[0][0] == 1 || obstacleGrid[m-1][n-1] == 1){
            return 0;
        }

        // 初始化，从1开始，起始行/列都是1
        // 但是 行/列 一遇到障碍就不能赋值了，因为不会再走下去了
        for(int i = 0; i < m && obstacleGrid[i][0] == 0; i++){
            dp[i][0] = 1;
        }
        for(int j = 0; j < n && obstacleGrid[0][j] == 0; j++){
            dp[0][j] = 1;
        }

        // 从左往右，从上到下遍历
        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                // 如果该点是障碍，则dp值应该为0，不能给下面的点加走法
                // 所以直接continue，在下一个点的计算中
                // dp的值就是直接用的初始化的0
                if(obstacleGrid[i][j] == 1){
                    continue;
                }
                // 无障碍则正常更新路径数
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }

        return dp[m-1][n-1];
    }
};
```
