# 232.用栈实现队列

力扣链接：https://leetcode.cn/problems/implement-queue-using-stacks/

---

一遇到这样要实现很多功能的，就会直接开抄，不想去自己想

---

**思路：**

看代码实现

---

## 全注释版

```cpp
class MyQueue {
public:
    // 定义两个栈：stin用于入队操作，stout用于出队操作
    stack<int> stin;   // 输入栈：用于存储新压入的元素
    stack<int> stout;  // 输出栈：用于存储准备弹出的元素
    
    // 构造函数：初始化队列（栈已自动初始化，无需特殊操作）
    MyQueue() {
        // 这里不需要做任何事，stack会自己初始化
    }
    
    // 入队操作：将元素x添加到队列尾部
    void push(int x) {
        stin.push(x);  // 直接将新元素压入输入栈
    }
    
    // 出队操作：移除并返回队列头部元素
    int pop() {
        // 只有当stout为空时，才需要从stin导入数据
        // 这样可以保证队列的先进先出顺序
        if(stout.empty()){
            // 将stin中的所有元素转移到stout中
            // 这样stout的栈顶就是队列的头部（最早进入的元素）
            while(!stin.empty()){
                // 取出stin的栈顶元素（最后进入的元素）
                stout.push(stin.top());
                // 从stin中移除该元素
                stin.pop();
            }
        }
        // 现在stout的栈顶就是队列的头部元素
        int result = stout.top();  // 获取队列头部元素
        stout.pop();               // 移除队列头部元素
        return result;             // 返回被移除的元素
    }
    
    // 查看队列头部元素但不移除
    int peek() {
        // 使用已有的pop函数获取头部元素
        int res = this->pop();  // 调用pop()获取头部元素，此时元素已从stout弹出
        stout.push(res);        // 将元素重新压回stout，因为peek只是查看不删除
        // 注意：这里重新压回后，元素的顺序仍然保持正确
        // 因为pop()已经确保了stout中元素的正确顺序
        return res;             // 返回队列头部元素
    }
    
    // 判断队列是否为空
    bool empty() {
        // 只有当两个栈都为空时，队列才为空
        return stin.empty() && stout.empty();
    }
};
```

## 算法原理总结：

这是一个**用两个栈实现队列**的经典算法：

1. **入队操作**：直接将元素压入 `stin` 栈
2. **出队/查看操作**：
   - 如果 `stout` 不为空，直接从 `stout` 弹出/查看栈顶元素
   - 如果 `stout` 为空，将 `stin` 中所有元素转移到 `stout`
     - 转移过程中元素顺序会反转，正好符合队列的先进先出特性

## 时间复杂度分析：
- `push()`: O(1) - 直接压栈
- `pop()`: 摊还时间复杂度 O(1) - 每个元素最多从 `stin` 转移到 `stout` 一次
- `peek()`: O(1) - 摊还时间复杂度
- `empty()`: O(1) - 直接检查两个栈

## 关键点：
- **两个栈的分工**：`stin` 只管入队，`stout` 只管出队
- **转移时机**：只有当 `stout` 为空时才从 `stin` 转移
- **顺序反转**：栈是后进先出(LIFO)，但经过一次转移就变成了先进先出(FIFO)
