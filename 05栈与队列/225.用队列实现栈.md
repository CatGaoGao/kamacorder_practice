# 225.用队列实现栈

力扣链接：https://leetcode.cn/problems/implement-stack-using-queues/

---

用一个队列实现栈，顺着思路理了一遍

---

**思路：**

见代码

---

## 全注释版本

```cpp
class MyStack {
public:
    // 使用一个队列来模拟栈
    // 队列是先进先出(FIFO)，栈是后进先出(LIFO)
    // 需要用队列实现栈的后进先出特性
    queue<int> que;  // 底层使用标准队列容器

    // 构造函数：初始化栈
    // 队列que会自动调用其默认构造函数进行初始化
    MyStack() {
        // 不需要特殊初始化操作
    }

    // 入栈操作：将元素x压入栈顶
    void push(int x) {
        // 直接调用队列的push操作
        // 新元素被添加到队列尾部
        que.push(x);
    }

    // 出栈操作：移除并返回栈顶元素（后进先出）
    int pop() {
        // 获取队列当前大小，即栈中元素个数
        int size = que.size();
        
        // 因为要获取栈顶元素（最后进入的元素）
        // 栈顶元素在队列的尾部，但队列只能从头部访问
        // 我们需要将队列前size-1个元素移到队列尾部
        // 这样原来队列尾部的元素（栈顶）就会到队列头部
        size--;  // 需要移动的元素个数 = 总元素数 - 1
        
        // 将前size-1个元素从队列头部移到队列尾部
        // 这样最后一个元素（栈顶）就会到队列头部
        while (size--) {
            // 将队列头部的元素重新添加到队列尾部
            que.push(que.front());
            // 移除队列头部的元素
            que.pop();
        }
        
        // 此时队列头部的元素就是原来的栈顶元素（最后push进来的元素）
        int result = que.front();  // 获取栈顶元素
        
        // 移除栈顶元素（队列头部元素）
        que.pop();
        
        // 返回被移除的栈顶元素
        return result;
    }

    // 获取栈顶元素但不移除（查看栈顶）
    int top() {
        // 获取队列当前大小
        int size = que.size();
        
        // 需要移动的元素个数 = 总元素数 - 1
        size--;
        
        // 将前size-1个元素从队列头部移到队列尾部
        // 这样栈顶元素（最后进入的元素）就会到队列头部
        while (size--) {
            // 将队列头部的元素重新添加到队列尾部
            que.push(que.front());
            // 移除队列头部的元素
            que.pop();
        }
        
        // 此时队列头部的元素就是栈顶元素
        int result = que.front();  // 获取栈顶元素
        
        // 因为是top操作，只需要查看栈顶，不应该移除元素
        // 所以需要将获取到的元素重新放回队列尾部，保持数据结构不变
        que.push(que.front());  // 将栈顶元素添加到队列尾部
        que.pop();              // 从队列头部移除栈顶元素
        
        // 现在栈顶元素在队列尾部，恢复了原来的状态
        // 返回栈顶元素
        return result;
    }

    // 判断栈是否为空
    bool empty() {
        // 栈为空等价于底层队列为空
        return que.empty();
    }
};
```

## 算法原理图解：

### 初始状态（模拟栈 [1,2,3]，3是栈顶）：
队列：1 ← 2 ← 3  （1在头部，3在尾部）

### 执行 pop() 操作：
1. `size = 3, size-- = 2`
2. 移动前2个元素到尾部：
   - 移动1：队列变为 2 ← 3 ← 1
   - 移动2：队列变为 3 ← 1 ← 2
3. 现在队列头部是3（栈顶元素）
4. 弹出3，返回3

### 执行 top() 操作：
1. 同样的移动操作，使栈顶元素到队列头部
2. 获取栈顶元素后，再把它放回队列尾部
3. 队列恢复原状

## 时间复杂度分析：
- **push(x)**: O(1) - 直接添加到队列尾部
- **pop()**: O(n) - 需要移动n-1个元素，其中n是栈的大小
- **top()**: O(n) - 同样需要移动n-1个元素
- **empty()**: O(1) - 直接检查队列是否为空

## 关键点：
1. **单队列实现**：只使用一个队列，通过元素重排实现栈的LIFO特性
2. **pop/top操作的核心**：将前n-1个元素移到队列尾部，使栈顶元素到达队列头部
3. **top与pop的区别**：top操作需要恢复队列原状，pop操作直接移除元素

## 变体：双队列实现（更高效）
```cpp
// 可以使用两个队列实现，使top()操作变为O(1)
// 但pop()操作仍需要O(n)的时间
```
