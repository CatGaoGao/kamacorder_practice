# 209.长度最小的子数组

力扣链接：https://leetcode.cn/problems/minimum-size-subarray-sum/

---

能想到思路但是就是实现不出来，一直报错

---

**思路：**

遍历：累加和、累加和比大小，下标互减

滑动窗口

1. for遍历数组，if寻找是否直接有单个元素==target，顺带算出数组每个元素的累加和sum   
2. for中while循环依次比对sum中元素与target，若>=则用下标算出元素个数（滑动窗口）   
3. 若有答案则返回答案，否则return 0

滑动窗口（代码随想录版本）   
```cpp
 while (sum >= s) {
                subLength = (j - i + 1); // 取子序列的长度
                result = result < subLength ? result : subLength;
                sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
            }
```


---

## 代码

    时间复杂度：O(n)
    空间复杂度：O(1)

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int slow = 0; // 滑动窗口起始
        int sum = 0; // 滑动窗口数值之和
        int ans = 0,temp = INT32_MAX;

        for(int fast = 0; fast < nums.size(); fast++){
            if(nums[fast] == target){
                return 1;
            }

            sum += nums[fast];

            while(sum >= target){ // 注意这里使用while，每次更新 slow（起始位置），并不断比较子序列是否符合条件
                ans = fast-slow +1; // 注意这里+1
                // e.g fast是2，slow是0，其实是3个数
                ans = min(ans,temp);

                temp = ans;
                sum -= nums[slow]; // 这里体现出滑动窗口的精髓之处，不断变更slow（子序列的起始位置）
                slow++;
            }
        }

        if(ans != 0){
            return ans;
        }
        else{
            return 0;
        }
    }
};
```
